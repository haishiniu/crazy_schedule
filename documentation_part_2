第一、背景知识
1.并发
在计算机中每一个线程都是一个执行任务，假设现在有一个单核的CPU，CPU每时每刻只能调度执行一个线程，我们第一种做法就是让所有的线程排好队，
一个任务一个任务的依次执行，执行完一个执行下一个。
采用这种方式的调度带来的问题就是，如果当前执行的任务陷入了死循环，那么CPU会一直卡在这个任务上，导致后续的任务无法执行。
所以，操作系统采用的方案是，每个任务分一个时间片来执行，时间片结束之后便切换任务，换另一个执行，这样就不会有线程饥饿的现象出现。

假设现在有8个任务，每个任务都分250ms进行计算，那么2s后，每个任务的拥有者都发现自己的任务往前进行了一点，这就是并发（concurrency）。
在POSIX中，并发的定义要求"延迟调用线程的函数不应该导致其他线程的无限期延迟"。
我们上面的八个任务中，并发操作之间可能任意交错，对任务的拥有者来说，2s后八个任务都往前推进了一部分，好像八个任务是并行执行的，
但是实际CPU执行任务的时候还是[一个一个]执行的，所以并发不代表操作同时进行。
那么如果有八个核心的CPU会怎么样呢，8个CPU核心会各自拿一个任务执行，这种情况才是并行。

2.并行
并行只在多处理器的情况下才存在，因为每个处理器可以各自执行一个任务，这时八个任务便是并行执行的。
单处理器的情况下是没办法做到并行的。所以即使在多核的CPU计算资源情况下，python的多线程没有达到并行而只能达到并发，因为多个线程无法同时被执行，
只能依次的执行。

3.上下文切换
为了实现并发，我们需要让CPU交替切换的执行不同的任务，但当操作系统从 thread1 切换到 thread2 的时候，操作系统实际上打断了 thread1 的执行流程
，那么下一次thread1重新被执行的时候，怎么能保证是继续上一次被打断的时候的位置继续执行的呢？所以切换的时候要保存任务的执行环境信息，
比如代码运行到哪一行了，哪些变量被赋值了，当时寄存器都是那些值等等。保存当前线程的执行环境信息，加载下一个线程的执行环境的操作就称为
上下文切换。有了上下文切换，我们就不用担心任务被打断后会丢失一些执行信息导致下一次接着执行的时候出错。

4.线程调度-->阻塞调用
当运行中的线程调用 sleep操作时，被阻塞，操作系统调度其他程序，直到该线程获得唤醒信号

CPU是非常稀缺的计算资源，每一纳秒都是珍贵的，所以我们调度任务的目标就是尽可能的让CPU不停的去计算，别让它空闲着。
当线程A中的代码调用了[文件读取]操作时，会发生什么呢？

def read_file(file_name = None):
    """
    读取文件操作
    """
    file_object = open("file_name")
    # 当执行这一步的时候，操作系统挂起当前线程，调度执行其他线程
    data = file_object.read()
    # 在未来的某个时刻，数据准备好了， 操作系统调度执行该线程，继续往下执行
    return data

由于存储的访问速度非常慢，CPU就会原地空转一直等着DMA把数据准备好，准备好了之后再往下执行。
那么CPU等待的这段时间就完全被空闲浪费了，因为CPU等待的时候还有其他的任务迫切的需要任务计算。
所以操作系统选择当线程A调用文件读取这样的阻塞操作的时候，就把线程A阻塞挂起，停止执行线程A，
然后调度另一个线程继续执行，当线程A需要的数据准备好了之后，操作系统便会在未来的某个时刻调度线程A继续执行，
如果线程A的数据始终都准备不好，那么线程A就永远不会被调度执行。

第二、协程的理解
协程是用户级的线程，是线程之上的轻量级线程

协程本质就是用户态下的线程，进程里的线程的切换调度是由操作系统来负责的。但是线程内的协程的调度执行，是由线程来负责的。
如果把协程对应到原生线程，那么协程所在的原生线程就是操作系统的角色。即原生线程需要负责什么时候切换协程，什么时候挂起协程。
协程切换的时候，线程需要把协程A的执行环境进行保存，在下一次执行A的时候，线程需要恢复执行环境，这样就可以从A之前的位置继续执行。


用户线程即为协程，操作系统感知不到协程的存在，只调度内核线程。

注意:
多线程的使用是可以让一个程序获得更多的计算时间的，但是协程的使用不会，
多线程的使用在多核的情况下，可以达到并行的效果，但是协程的使用不会达到并行的效果。因为操作系统感知不到协程的存在，只会把时间片和CPU核心分给线程。
至于分给线程的时间，线程又会分配给哪个协程来运行，那是线程自己决定的内容。
eg:
比如分配2ms给一个拥有两个协程的线程A，线程被操作系统调度指派给了CPU核心C1， A会决定在C1运行哪个线程，,可以雨露均沾，让两个协程各自运行1ms,
也可以是把2ms全部分配给一个协程，自始至终，所有的协程都运行在CPU核心C1上，所以无法实现协程并行。


线程内部自主进行协程调度
那使用协程的好处是什么呢？
提高线程的并发度，减小切换的开销.
结论是:协程的切换只是线程栈内的切换操作，不涉及内核操作，其切换速度远快于线程。

如果我们要实现协程调度，我们该实现哪些功能呢?
比如有一个线程底下有两个协程A，B，根据用户输入的文件名，A协程进行文件读取，并返回文件内容，B协程根据文件名计算哈希值并返回。

# demo code

def coroutine_A(file_path):
    file_object = open(file_path)
    # 协程执行到文件阅读，则挂起协程，切换到B
    data = file_object.read()
    # 数据准备好之后，线程获得通知，然后在未来某个时刻调度协程A继续执行
    file_object.close()
    return data

def coroutine_B(file_path):
    hash_value = Hash(file_path)
    return hash_value

线程首先调度执行A，执行到文件读取部分发现需要等待，于是挂起协程A并切换到协程B执行。
所以要实现调度协程，那么至少需要实现协程【挂起】操作和协程【恢复】运行两个操作，
如果不想手动进行调度，那么可以实现一个【中央的调度器】来帮助进行【调度】。

第三、协程的实现
python3.4 之后引入了asyncio模块，使得协程的使用更加的方便，其中关键词async表明这一块函数是一个协程块，
而不是普通的函数模块（函数模块从中间退出之后，是不会保留运行环境的，但是协程会保留）, await关键字表明协程主动出让执行权。
我们定义三个协程模块，并让调度器进行调度执行A和B。首先调度运行协程B, 运行到sleep函数的时候遇到await关键字并出让执行权，这时调度器切换执行协程A，
协程A执行又遇到await，再一次出让执行权。这时两个协程都在等待唤醒的信号。等待到了信号之后，两个协程被唤醒进而调度执行，然后运行结束。
具体的代码实现 请参看 part_2/two_schedule.py

当使用三个协程时候，第三个协程进行调度，这样当A、B等待时钟信号的时候我们在等待的期间，让调度器执行调度协程C，
虽然协程C也调用sleep函数，但是由于睡眠时间短，所以很快又会被唤醒进行调度执行。当然了，由于协程C是死循环，
所以协程A、B结束之后，会一直执行协程C。
具体代码实现 请参看 part_2/three_schedule.py

协程的两大特点:
一是可以保存运行时环境，
另一个便是可以主动出让执行权。

那么假如有一个协程C始终不出让执行权，即不用await关键字，那么其他协程是不是就没办法被执行了呢?
通过测试发现:的确是这样的。
具体代码实现 请参看 part_2/not_await.py